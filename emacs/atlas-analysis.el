;;; atlas-analysis.el --- Analysis commands for Atlas IDE support -*- lexical-binding: t -*-

;; Copyright (C) 2025
;; Author: @tangrammer + LLMs

;;; Commentary:
;;
;; Advanced analysis commands for Atlas Emacs integration:
;; - Impact analysis and refactoring preview
;; - Architecture and operations views
;; - Compliance (PII, error handling)
;; - Ontology tools (suggest aspects, inspect, templates)

;;; Code:

(require 'atlas-core)
(require 'atlas-display)
(require 'atlas-completion)

;;;###autoload
(defun atlas-analysis-trace-data-flow (data-key)
  "Trace how DATA-KEY flows through the system."
  (interactive (list (atlas--completing-read-data-key "Data key: ")))
  (let* ((data-kw (atlas--to-keyword data-key))
         (result (atlas--eval (format "(trace-data-flow %s)" data-kw)))
         (buf (atlas--buffer (format "trace-flow-%s" data-key))))
    (with-current-buffer buf
      (atlas--insert-header (format "Data Flow: %s" data-key))
      (if (not result)
          (insert "  (error retrieving data flow)\n")
        (atlas--insert-subheader "Producers")
        (let ((producers (atlas--to-list (or (atlas--get result 'dataflow/produced-by)
                                              (atlas--get result 'produced-by)))))
          (if (and producers (> (length producers) 0))
              (dolist (prod producers)
                (insert "  ")
                (atlas--insert-entity prod)
                (insert "\n"))
            (insert "  (none)\n")))
        (insert "\n")
        (atlas--insert-subheader "Consumers")
        (let ((consumers (atlas--to-list (or (atlas--get result 'dataflow/consumed-by)
                                              (atlas--get result 'consumed-by)))))
          (if (and consumers (> (length consumers) 0))
              (dolist (consumer consumers)
                (insert "  ")
                (atlas--insert-entity consumer)
                (insert "\n"))
            (insert "  (none)\n")))
        (insert "\n")
        (let ((connected (or (atlas--get result 'dataflow/connected?)
                             (atlas--get result 'connected?))))
          (insert (format "Connected: %s\n" (if connected "yes" "no")))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-impact-of-change (entity-id)
  "Show what would be affected if ENTITY-ID changes."
  (interactive (list (atlas--completing-read-entity "Entity: ")))
  (let* ((entity-kw (atlas--to-keyword entity-id))
         (result (atlas--eval (format "(impact-of-change %s)" entity-kw)))
         (buf (atlas--buffer (format "impact-%s" entity-id))))
    (with-current-buffer buf
      (atlas--insert-header (format "Impact Analysis: %s" entity-id))
      (if (not result)
          (insert "  (error retrieving impact data)\n")
        (atlas--insert-subheader "Produces")
        (let ((produces (atlas--to-list (or (atlas--get result 'impact/produces)
                                             (atlas--get result 'entity/produces)))))
          (if (and produces (> (length produces) 0))
              (dolist (item produces)
                (insert (format "  %s\n" item)))
            (insert "  (nothing)\n")))
        (insert "\n")
        (atlas--insert-subheader "Direct Dependents (would break)")
        (let ((deps (atlas--to-list (or (atlas--get result 'impact/direct-dependents)
                                         (atlas--get result 'direct-dependents)))))
          (if (and deps (> (length deps) 0))
              (dolist (dep deps)
                (insert "  ")
                (atlas--insert-entity dep)
                (insert "\n"))
            (insert "  (none)\n"))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-domain-coupling ()
  "Analyze inter-domain dependencies."
  (interactive)
  (let* ((result (atlas--eval "(domain-coupling)"))
         (buf (atlas--buffer "domain-coupling")))
    (with-current-buffer buf
      (atlas--insert-header "Domain Coupling Analysis")
      (if (not result)
          (insert "  (error retrieving coupling data)\n")
        (let ((coupling-list (atlas--to-list result)))
          (if (and coupling-list (> (length coupling-list) 0))
              (dolist (item coupling-list)
                (let ((domain (or (atlas--get item 'coupling/domain)
                                  (atlas--get item 'domain)))
                      (depends-on (atlas--to-list (or (atlas--get item 'coupling/depends-on)
                                                       (atlas--get item 'depends-on))))
                      (entity-count (or (atlas--get item 'coupling/entity-count)
                                        (atlas--get item 'entity-count) 0)))
                  (when domain
                    (atlas--insert-subheader (format "%s (%d entities)" domain entity-count))
                    (if (and depends-on (> (length depends-on) 0))
                        (progn
                          (insert "  Depends on:\n")
                          (dolist (dep depends-on)
                            (insert (format "    %s\n" dep))))
                      (insert "  (no dependencies)\n"))
                    (insert "\n"))))
            (insert "  (no domain coupling data)\n"))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-pii-surface ()
  "Show all entities handling PII."
  (interactive)
  (let* ((result (atlas--eval "(pii-surface)"))
         (buf (atlas--buffer "pii-surface")))
    (with-current-buffer buf
      (atlas--insert-header "PII Surface Analysis")
      (if (not result)
          (insert "  (error retrieving PII data)\n")
        (let ((items (atlas--to-list result)))
          (if (and items (> (length items) 0))
              (dolist (item items)
                (let ((id (or (atlas--get item 'pii/id) (atlas--get item 'id)))
                      (audited (or (atlas--get item 'pii/audited?) (atlas--get item 'audited?))))
                  (when id
                    (insert "  ")
                    (atlas--insert-entity id)
                    (insert (format " [%s]\n" (if audited "audited" "NOT AUDITED"))))))
            (insert "  (no PII-handling entities found)\n"))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-error-handler-coverage ()
  "Check error handler coverage."
  (interactive)
  (let* ((result (atlas--eval "(error-handler-coverage)"))
         (buf (atlas--buffer "error-handlers")))
    (with-current-buffer buf
      (atlas--insert-header "Error Handler Coverage")
      (atlas--insert-subheader "Registered Handlers")
      (let ((handlers (atlas--to-list (or (atlas--get result 'error-handler/handlers)
                                           (atlas--get result 'handlers)))))
        (dolist (handler handlers)
          (let ((id (or (atlas--get handler 'error-handler/id) (atlas--get handler 'id))))
            (insert "  ")
            (atlas--insert-entity id)
            (insert "\n"))))
      (insert "\n")
      (atlas--insert-subheader "Coverage Analysis")
      (let ((coverage (atlas--to-list (or (atlas--get result 'error-handler/coverage)
                                           (atlas--get result 'coverage)))))
        (dolist (item coverage)
          (let ((entity (or (atlas--get item 'error-handler/entity) (atlas--get item 'entity)))
                (concern (or (atlas--get item 'error-handler/concern) (atlas--get item 'concern)))
                (has-handler (or (atlas--get item 'error-handler/has-handler?) (atlas--get item 'has-handler?))))
            (insert (format "  %s - %s: %s\n" entity concern (if has-handler "yes" "no"))))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-suggest-aspects (entity-id)
  "Suggest aspects for ENTITY-ID based on similar entries."
  (interactive (list (atlas--completing-read-entity "Entity: ")))
  (let* ((entity-kw (atlas--to-keyword entity-id))
         (result (atlas--eval (format "(suggest-aspects %s)" entity-kw)))
         (buf (atlas--buffer (format "suggest-%s" entity-id))))
    (with-current-buffer buf
      (atlas--insert-header (format "Aspect Suggestions: %s" entity-id))
      (atlas--insert-subheader "Similar Entries")
      (let ((similar (atlas--to-list (or (atlas--get result 'ontology/similar-entries)
                                          (atlas--get result 'similar-entries)))))
        (dolist (sim similar)
          (unless (and (stringp sim) (string-prefix-p "(edn-set" sim))
            (insert (format "  %s\n" sim)))))
      (insert "\n")
      (atlas--insert-subheader "Suggested Aspects")
      (let ((suggested (atlas--to-list (or (atlas--get result 'ontology/suggested-aspects)
                                            (atlas--get result 'suggested-aspects)))))
        (if (and suggested (> (length suggested) 0))
            (dolist (asp suggested)
              (insert "  ")
              (atlas--insert-aspect asp)
              (insert "\n"))
          (insert "  (no suggestions)\n")))
      (insert "\n")
      (insert (format "Rationale: %s\n" (or (atlas--get result 'ontology/rationale)
                                             (atlas--get result 'rationale))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-inspect-entity (entity-id)
  "Quick inspection of ENTITY-ID."
  (interactive (list (atlas--completing-read-entity "Entity: ")))
  (let* ((entity-kw (atlas--to-keyword entity-id))
         (result (atlas--eval (format "(inspect-entity %s)" entity-kw)))
         (buf (atlas--buffer (format "inspect-%s" entity-id))))
    (with-current-buffer buf
      (atlas--insert-header (format "Inspect: %s" entity-id))
      (insert (format "Dev ID: %s\n" (or (atlas--get result 'inspection/dev-id)
                                          (atlas--get result 'entity/dev-id))))
      (when-let ((aspect-count (or (atlas--get result 'inspection/aspect-count)
                                   (atlas--get result 'aspect-count))))
        (insert (format "Aspects: %d\n" aspect-count)))
      (insert "\n")
      (atlas--insert-subheader "Semantic Identity")
      (let ((identity (atlas--to-list (or (atlas--get result 'inspection/semantic-identity)
                                           (atlas--get result 'semantic-identity)))))
        (dolist (asp identity)
          (insert "  ")
          (atlas--insert-aspect asp)
          (insert "\n")))
      (insert "\n")
      (when-let ((docs (or (atlas--get result 'inspection/docs) (atlas--get result 'docs))))
        (atlas--insert-subheader "Documentation")
        (insert (format "%s\n" docs)))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-aspect-catalog ()
  "Show all aspects with usage statistics."
  (interactive)
  (let* ((result (atlas--eval "(aspect-catalog)"))
         (buf (atlas--buffer "aspect-catalog")))
    (with-current-buffer buf
      (atlas--insert-header "Aspect Catalog")
      (let ((catalog (atlas--to-list result)))
        (dolist (ns-group catalog)
          (let* ((ns-name (or (atlas--get ns-group 'aspect-catalog/namespace)
                              (atlas--get ns-group 'namespace)))
                 (items (or (atlas--get ns-group 'aspect-catalog/items)
                            (atlas--get ns-group 'items))))
            (when ns-name
              (atlas--insert-subheader (format "Namespace: %s" ns-name))
              (dolist (asp-data (atlas--to-list items))
                (let ((aspect (or (atlas--get asp-data 'aspect-catalog/aspect)
                                  (atlas--get asp-data 'aspect)))
                      (usage (or (atlas--get asp-data 'aspect-catalog/usage-count)
                                 (atlas--get asp-data 'usage-count) 0)))
                  (insert "  ")
                  (atlas--insert-aspect aspect)
                  (insert (format " (%d uses)\n" usage))))
              (insert "\n")))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-list-templates ()
  "List available entity templates."
  (interactive)
  (let* ((result (atlas--eval "(list-templates)"))
         (buf (atlas--buffer "templates")))
    (with-current-buffer buf
      (atlas--insert-header "Entity Templates")
      (let ((templates (atlas--to-list result)))
        (dolist (template templates)
          (let ((name (or (atlas--get template 'template/name) (atlas--get template 'name)))
                (params (atlas--to-list (or (atlas--get template 'template/params)
                                             (atlas--get template 'params))))
                (desc (or (atlas--get template 'template/description)
                          (atlas--get template 'description))))
            (when name
              (atlas--insert-subheader (atlas--to-string name))
              (when desc (insert (format "  Description: %s\n" desc)))
              (when params
                (insert "  Parameters: ")
                (insert (mapconcat #'atlas--to-string params ", ")))
              (insert "\n\n")))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-similar-entities (entity-id)
  "Find entities with similar semantic profiles to ENTITY-ID."
  (interactive (list (atlas--completing-read-entity "Entity: ")))
  (let* ((entity-kw (atlas--to-keyword entity-id))
         (result (atlas--eval (format "(semantic-similarity %s)" entity-kw)))
         (buf (atlas--buffer (format "similar:%s" entity-id))))
    (with-current-buffer buf
      (setq atlas--last-command (lambda () (atlas-analysis-similar-entities entity-id)))
      (atlas--insert-header (format "Similar to %s" entity-id))
      (let ((items (atlas--to-list result)))
        (if (and items (> (length items) 0))
            (dolist (item items)
              (let ((entity (or (atlas--get item 'similarity/entity) (atlas--get item 'entity)))
                    (score (or (atlas--get item 'similarity/score) (atlas--get item 'score)))
                    (shared (atlas--to-list (or (atlas--get item 'similarity/shared-aspects)
                                                 (atlas--get item 'shared-aspects)))))
                (insert "  ")
                (atlas--insert-entity entity)
                (insert (format " (%.0f%% similar)\n" (* 100 (or score 0))))
                (when shared
                  (insert "    Shared: ")
                  (let ((first t))
                    (dolist (asp shared)
                      (unless first (insert ", "))
                      (setq first nil)
                      (atlas--insert-aspect asp)))
                  (insert "\n"))
                (insert "\n")))
          (insert "  (no similar entities found)\n")))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-by-tier ()
  "Show all entities grouped by architectural tier."
  (interactive)
  (let* ((result (atlas--eval "(by-tier)"))
         (buf (atlas--buffer "by-tier")))
    (with-current-buffer buf
      (setq atlas--last-command #'atlas-analysis-by-tier)
      (atlas--insert-header "Entities by Tier")
      (let ((tiers (atlas--to-list result)))
        (dolist (tier-data tiers)
          (let ((tier-name (or (atlas--get tier-data 'tier/name) (atlas--get tier-data 'name)))
                (entities (atlas--to-list (or (atlas--get tier-data 'tier/entities)
                                               (atlas--get tier-data 'entities))))
                (count (or (atlas--get tier-data 'tier/count) (atlas--get tier-data 'count) 0)))
            (when tier-name
              (atlas--insert-subheader (format "%s (%d)" tier-name count))
              (if entities
                  (dolist (entity entities)
                    (insert "  ")
                    (atlas--insert-entity entity)
                    (insert "\n"))
                (insert "  (none)\n"))
              (insert "\n")))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-architecture-view ()
  "Show architecture documentation: entities by tier and domain."
  (interactive)
  (let* ((result (atlas--eval "(architecture-view)"))
         (buf (atlas--buffer "architecture")))
    (with-current-buffer buf
      (setq atlas--last-command #'atlas-analysis-architecture-view)
      (atlas--insert-header "Architecture View")
      (atlas--insert-subheader "By Tier")
      (let ((tiers (atlas--to-list (or (atlas--get result 'architecture/tiers)
                                        (atlas--get result 'tiers)))))
        (dolist (tier-data tiers)
          (let ((tier-name (or (atlas--get tier-data 'tier/name) (atlas--get tier-data 'name)))
                (count (or (atlas--get tier-data 'tier/count) (atlas--get tier-data 'count) 0)))
            (when tier-name
              (insert (format "  %s: %d entities\n" tier-name count))))))
      (insert "\n")
      (atlas--insert-subheader "By Domain")
      (let ((domains (atlas--to-list (or (atlas--get result 'architecture/domains)
                                          (atlas--get result 'domains)))))
        (dolist (domain-data domains)
          (let ((domain-name (or (atlas--get domain-data 'domain/name) (atlas--get domain-data 'name)))
                (entities (atlas--to-list (or (atlas--get domain-data 'domain/entities)
                                               (atlas--get domain-data 'entities))))
                (count (or (atlas--get domain-data 'domain/count) (atlas--get domain-data 'count) 0)))
            (when domain-name
              (insert "\n")
              (insert (format "  %s (%d)\n" domain-name count))
              (dolist (entity entities)
                (insert "    ")
                (atlas--insert-entity entity)
                (insert "\n"))))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-operations-view ()
  "Show operations documentation: external integrations, pure functions, OAuth."
  (interactive)
  (let* ((result (atlas--eval "(operations-view)"))
         (buf (atlas--buffer "operations")))
    (with-current-buffer buf
      (setq atlas--last-command #'atlas-analysis-operations-view)
      (atlas--insert-header "Operations View")
      (let ((ext (or (atlas--get result 'operations/external-integrations)
                     (atlas--get result 'external-integrations))))
        (atlas--insert-subheader "External Integrations")
        (insert (format "  %s\n\n" (or (atlas--get ext 'description) "")))
        (let ((entities (atlas--to-list (atlas--get ext 'entities))))
          (dolist (entity entities)
            (insert "  ")
            (atlas--insert-entity entity)
            (insert "\n")))
        (insert "\n  Operational Concerns:\n")
        (let ((concerns (atlas--to-list (atlas--get ext 'concerns))))
          (dolist (concern concerns)
            (insert (format "    - %s\n" concern)))))
      (insert "\n")
      (let ((pure (or (atlas--get result 'operations/pure-functions)
                      (atlas--get result 'pure-functions))))
        (atlas--insert-subheader "Pure Functions")
        (insert (format "  %s\n\n" (or (atlas--get pure 'description) "")))
        (let ((entities (atlas--to-list (atlas--get pure 'entities))))
          (dolist (entity entities)
            (insert "  ")
            (atlas--insert-entity entity)
            (insert "\n")))
        (insert "\n  Operational Concerns:\n")
        (let ((concerns (atlas--to-list (atlas--get pure 'concerns))))
          (dolist (concern concerns)
            (insert (format "    - %s\n" concern)))))
      (insert "\n")
      (let ((oauth (or (atlas--get result 'operations/oauth-dependencies)
                       (atlas--get result 'oauth-dependencies))))
        (atlas--insert-subheader "OAuth Dependencies")
        (insert (format "  %s\n\n" (or (atlas--get oauth 'description) "")))
        (let ((entities (atlas--to-list (atlas--get oauth 'entities))))
          (if entities
              (dolist (entity entities)
                (insert "  ")
                (atlas--insert-entity entity)
                (insert "\n"))
            (insert "  (none)\n")))
        (insert "\n  Operational Concerns:\n")
        (let ((concerns (atlas--to-list (atlas--get oauth 'concerns))))
          (dolist (concern concerns)
            (insert (format "    - %s\n" concern)))))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-aspect-impact (aspect)
  "Analyze what would be affected by changes to ASPECT."
  (interactive (list (atlas--completing-read-aspect "Aspect: ")))
  (let* ((aspect-kw (atlas--to-keyword aspect))
         (result (atlas--eval (format "(aspect-impact %s)" aspect-kw)))
         (buf (atlas--buffer (format "aspect-impact:%s" aspect))))
    (with-current-buffer buf
      (setq atlas--last-command (lambda () (atlas-analysis-aspect-impact aspect)))
      (atlas--insert-header (format "Impact of changing %s" aspect))
      (let ((total (or (atlas--get result 'aspect-impact/total)
                       (atlas--get result 'total) 0)))
        (insert (format "Total affected: %d entities\n\n" total)))
      (atlas--insert-subheader "By Tier")
      (let ((by-tier (or (atlas--get result 'aspect-impact/by-tier)
                         (atlas--get result 'by-tier))))
        (if (hash-table-p by-tier)
            (maphash (lambda (k v) (insert (format "  %s: %d\n" k v))) by-tier)
          (when (listp by-tier)
            (dolist (pair by-tier)
              (insert (format "  %s: %s\n" (car pair) (cdr pair)))))))
      (insert "\n")
      (atlas--insert-subheader "By Type")
      (let ((by-type (or (atlas--get result 'aspect-impact/by-type)
                         (atlas--get result 'by-type))))
        (if (hash-table-p by-type)
            (maphash (lambda (k v) (insert (format "  %s: %d\n" k v))) by-type)
          (when (listp by-type)
            (dolist (pair by-type)
              (insert (format "  %s: %s\n" (car pair) (cdr pair)))))))
      (insert "\n")
      (atlas--insert-subheader "Example Entities")
      (let ((examples (atlas--to-list (or (atlas--get result 'aspect-impact/examples)
                                           (atlas--get result 'examples)))))
        (if examples
            (dolist (entity examples)
              (insert "  ")
              (atlas--insert-entity entity)
              (insert "\n"))
          (insert "  (none)\n")))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-preview-refactor (old-aspect new-aspect)
  "Preview what would happen if OLD-ASPECT is renamed to NEW-ASPECT."
  (interactive
   (list (atlas--completing-read-aspect "Old aspect: ")
         (read-string "New aspect: ")))
  (let* ((old-kw (atlas--to-keyword old-aspect))
         (new-kw (atlas--to-keyword new-aspect))
         (result (atlas--eval (format "(preview-refactor-aspect %s %s)" old-kw new-kw)))
         (buf (atlas--buffer (format "refactor:%s->%s" old-aspect new-aspect))))
    (with-current-buffer buf
      (setq atlas--last-command (lambda () (atlas-analysis-preview-refactor old-aspect new-aspect)))
      (atlas--insert-header (format "Refactor Preview: %s -> %s" old-aspect new-aspect))
      (let ((affected (or (atlas--get result 'refactor/affected-count)
                          (atlas--get result 'affected-count) 0))
            (conflicts (atlas--to-list (or (atlas--get result 'refactor/conflicts)
                                            (atlas--get result 'conflicts)))))
        (insert (format "Affected entities: %d\n" affected))
        (if (and conflicts (> (length conflicts) 0))
            (insert (propertize (format "Conflicts: %d (would collide!)\n" (length conflicts))
                                'face 'atlas-error-face))
          (insert (propertize "Conflicts: none\n" 'face 'atlas-success-face))))
      (insert "\n")
      (atlas--insert-subheader "Migrations")
      (let ((migrations (atlas--to-list (or (atlas--get result 'refactor/migrations)
                                             (atlas--get result 'migrations)))))
        (if migrations
            (dolist (mig migrations)
              (let ((dev-id (or (atlas--get mig 'refactor/dev-id) (atlas--get mig 'dev-id)))
                    (will-collide (or (atlas--get mig 'refactor/will-collide?)
                                      (atlas--get mig 'will-collide?))))
                (insert "  ")
                (atlas--insert-entity dev-id)
                (when will-collide
                  (insert (propertize " [COLLISION]" 'face 'atlas-error-face)))
                (insert "\n")))
          (insert "  (no migrations needed)\n")))
      (insert "\n")
      (insert (propertize "Note: This is a dry-run preview. No changes have been made.\n"
                          'face 'font-lock-comment-face))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

;;;###autoload
(defun atlas-analysis-llm-context ()
  "Export full documentation context for LLM consumption."
  (interactive)
  (let* ((result (atlas--eval "(llm-context)"))
         (buf (atlas--buffer "llm-context")))
    (with-current-buffer buf
      (atlas--insert-header "LLM Documentation Context")
      (insert (propertize "Full system context optimized for LLM consumption.\n\n"
                          'face 'font-lock-comment-face))
      (if result
          (let ((pp-str (pp-to-string result)))
            (insert pp-str))
        (insert "(error retrieving context)\n"))
      (goto-char (point-min))
      (read-only-mode 1))
    (pop-to-buffer buf)))

(provide 'atlas-analysis)
;;; atlas-analysis.el ends here
